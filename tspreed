#!/bin/sh

# Copyright (c) 2021 Nicholas Ivkovic.
# Licensed under the GNU General Public License version 3 or later. See ./LICENSE, or <https://gnu.org/licenses/gpl.html> if more recent, for details.
# This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law.

# Notes about disabled ShellChecks:
#   SC1090 -- Config files do not need to/cannot be checked as they are user-written. Default config is checked separately
#   SC2015 -- Disabled where behaviour resembling an if-then-else is not intended
#   SC2059 -- Disabled where escape sequences are intended to be interpreted

# Exit from caught signals
exit_catch() {
	[ "$term_presenting" = true ] && end_term 8
	! [ "$quietexit" = true ] && printf "%s/%s\n" "$word_num" "$words_count"
	exit 8
}

# Exit from error
# $1 return value
# $2 error message
exit_err() {
	[ "$term_presenting" = true ] && end_term "$1"
	[ "$1" -eq 3 ] && printf "Terminal does not support capability '%s'\n" "$2" >&2 || printf "%s\n" "$2" >&2
	[ "$1" -eq 1 ] && printf "Usage: tspreed [-lqhifbv] [-w wpm] [-n num] [-p style] [-c color]\n" >&2
	printf "See 'man tspreed'\n" >&2
	exit "$1"
}

# Move cursor to position
# $1 row
# $2 column
term_move() {
	tput cup "$1" "$2" 2>/dev/null || printf "\033[%s;%sH" "$1" "$2"
}

# Set foreground color
# $1 color
term_color() {
	tput setaf "$1" 2>/dev/null || {
		# shellcheck disable=SC2015
		[ "$1" -le 7 ] && printf "\033[3%sm" "$1" || exit_err 3 "setaf"
	}
}

# Initialise output
init_output() {
	# shellcheck disable=SC2059
	printf "$term_clear"
	[ "$focus" = true ] && {
		term_move $((term_y_center - 1)) "$term_x_center" && printf "%s" "$focus_pointer_1"
		term_move $((term_y_center + 1)) "$term_x_center" && printf "%s" "$focus_pointer_2"
	}
}

# Initialise terminal output
init_term() {
	term_height="$(tput lines)" 2>/dev/null || {
		# shellcheck disable=SC2015
		[ -n "$LINES" ] && [ "$LINES" -gt 0 ] 2>/dev/null && term_height="$LINES" || exit_err 3 "lines"
	}
	term_width="$(tput cols)" 2>/dev/null || {
		# shellcheck disable=SC2015
		[ -n "$COLUMNS" ] && [ "$COLUMNS" -gt 0 ] 2>/dev/null && term_width="$COLUMNS" || exit_err 3 "cols"
	}
	term_x_center=$((term_width / 2))
	term_y_center=$((term_height / 2))
	init_output
}

# Finish terminal output
# $1 return value of exit function
end_term() {
	term_presenting=false
	if [ "$term_session" = true ]; then
		tput rmcup || exit_err 3 "rmcup"
	else
		if [ "$1" -eq 8 ]; then
			term_move $((term_height - 1)) 0
		else
			term_move "$term_height" 0
		fi
	fi
	# shellcheck disable=SC2059
	printf "$term_reset"
	[ "$hidecursor" = true ] && {
		tput cnorm 2>/dev/null || exit_err 3 "cnorm"
	}
}

# Get current epoch timestamp in milliseconds
get_date() {
	[ "$non_posix_date_s" = true ] && echo $(($(date -u "+%s%N / 1000000"))) || echo $(($(printf "%.0f" "$(date -u "+%S")") + $(printf "%.0f" "$(date -u "+%M")")$(date -u "+ * 60 + %k * 3600 + (")$(printf "%.0f" "$(date -u "+%j")")$(date -u "+ - 1) * 86400 + ((%Y - 1900) - 70) * 31536000 + (((%Y - 1900) - 69) / 4) * 86400 - (((%Y - 1900) - 1) / 100) * 86400 + (((%Y - 1900) + 299) / 400) * 86400%N / 1000000")))
}

# Perform floating point calculation
# $1 Calculation to perform
calc_float() {
	awk "BEGIN { print ${1} }"
}

# Import configs
config_global="/etc/tspreed/tspreed.rc"
config_local="${XDG_CONFIG_HOME:-$HOME/.config}/tspreed/tspreed.rc"
# shellcheck disable=SC1090
[ -f "$config_global" ] && . "$config_global"
# shellcheck disable=SC1090
[ -f "$config_local" ] && . "$config_local"

# Init
term_presenting=false
word_first=true
word_num=0
word_len_average=5 # Based on average English word length of 5.1 letters

trap "exit_catch" 2    # SIGINT
trap "exit_catch" 3    # SIGQUIT
trap "exit_catch" 6    # SIGABRT
trap "exit_catch" 14   # SIGALRM
trap "exit_catch" 15   # SIGTERM
trap "init_term" WINCH # Terminal emulator resize

while getopts ":w:n:s:qhilfp:bc:v" opt; do
	case "$opt" in
		w) wpm=$OPTARG ;;
		n) numstart="$OPTARG" ;;
		s) separators="$OPTARG" ;;
		l) lengthvary=true ;;
		q) quietexit=true ;;
		h) hidecursor=true ;;
		i) proginfo=true ;;
		f) focus=true ;;
		p) focuspointer="$OPTARG" ;;
		b) focusbold=true ;;
		c) focuscolor="$OPTARG" ;;
		v) printf "tspreed 2.2.0\n" && exit 0 ;;
		\?) exit_err 1 "Invalid option '-${OPTARG}'" ;;
		:) exit_err 1 "Option -${OPTARG} requires an argument." ;;
	esac
done

# Validate word speed
[ -z "$wpm" ] && exit_err 1 "WPM not set"
! { [ "$wpm" -ge 1 ] && [ "$wpm" -le 60000 ]; } 2>/dev/null && exit_err 1 "Invalid WPM '${wpm}'"

# Validate and set nth word as starting word
[ -n "$numstart" ] && ! [ "$numstart" -ge 1 ] 2>/dev/null && exit_err 1 "Invalid starting word position '${numstart}'"
[ -z "$numstart" ] && numstart=1

# Validate focus letter options
[ "$focus" = true ] && {
	# Validate and set focus letter pointers
	focus_pointer_1=
	focus_pointer_2=
	[ -n "$focuspointer" ] && [ "$focuspointer" != "none" ] && {
		case "$focuspointer" in
			line)  focus_pointer_1="|" && focus_pointer_2="|" ;;
			point) focus_pointer_1="v" && focus_pointer_2="^" ;;
			*) exit_err 1 "Invalid focus letter pointer '${focuspointer}'" ;;
		esac
	}
	# Validate focus letter color
	[ -n "$focuscolor" ] && ! { [ "$focuscolor" -ge 0 ] && [ "$focuscolor" -le 255 ]; } 2>/dev/null && exit_err 1 "Invalid focus letter color '${focuscolor}'"
}

# Test non-POSIX features
sleep 0.0 2>/dev/null && non_posix_sleep=true || non_posix_sleep=false
usleep 0 2>/dev/null && non_posix_usleep=true || non_posix_usleep=false
date_nano_format="$(date "+%N")" 2>/dev/null
[ -n "${date_nano_format##*N*}" ] && non_posix_date_n=true || non_posix_date_n=false
! [ "$non_posix_sleep" = true ] && ! [ "$non_posix_usleep" = true ] && ! [ "$non_posix_date_n" = true ] && exit_err 2 "System does not support required non-POSIX features or commands"
! [ "$(date "+%s")" = "%s" ] 2>/dev/null &&  non_posix_date_s=true || non_posix_date_s=false

# Set term capabilities
term_reset="$(tput sgr0 2>/dev/null || printf "\033[m")"
term_home="$(tput home 2>/dev/null || printf "\033[H")"
term_bold="$(tput bold 2>/dev/null || printf "\033[1m")"
term_clear_line="$(tput el 2 2>/dev/null || printf "\033[2K")"
[ -n "$(tput smcup 2>/dev/null)" ] && [ -n "$(tput rmcup 2>/dev/null)" ] && term_session=true || term_session=false
! [ "$term_session" = true ] && term_clear="$(printf "%s%s" "$term_home" "$(tput ed 2 2>/dev/null || printf "\033[2J")")" || term_clear="$(tput clear)" 2>/dev/null

# Set IFS
IFS="$(printf "%b%b" "$IFS" "$separators")"

# Get input
input=
while read -r inp; do
	input="${input}${inp} "
done
# Remove \r as they break looping over each word
input="$(printf "%s" "$input" | sed "s/\\r//g")"

# Init presentation
words_count=$(printf "%s" "$input" | wc -w | tr -d "[:space:]")
if [ "$term_session" = true ]; then
	tput smcup || exit_err 3 "smcup"
else
	# shellcheck disable=SC2059
	printf "$term_clear"
fi
term_presenting=true
[ "$hidecursor" = true ] && {
	tput civis 2>/dev/null || exit_err 3 "civis"
}
init_term

# Present
for word in $input; do

	# Init word 
	word_num=$((word_num + 1))
	[ "$word_num" -lt "$numstart" ] && continue
	word_len=${#word}
	word_x=0

	# Clear word
	if [ "$prev_word_len_exceed" = true ] && [ "$word_num" -lt "$words_count" ]; then
		init_output
	else
		term_move "$term_y_center" 0
		# shellcheck disable=SC2059
		printf "$term_clear_line"
	fi

	[ "$non_posix_date_n" = true ] && word_start_date="$(get_date)"

	# Focus letter highlighting enabled
	if [ "$focus" = true ]; then

		# Set focus letter
		case "$word_len" in
			1|2)         word_focus_pos=1 ;;
			3|4|5)       word_focus_pos=2 ;;
			6|7|8|9)     word_focus_pos=3 ;;
			10|11|12|13) word_focus_pos=4 ;;
			*)           word_focus_pos=5 ;;
		esac

		# Set horizontal position of word
		word_x=$((term_x_center - word_focus_pos + 1))
		term_move "$term_y_center" "$word_x"

		# Print start of word
		[ "$word_focus_pos" -gt 1 ] && printf "%s" "$(printf "%s" "$word" | cut -c -$((word_focus_pos - 1)))"

		# Print focus letter of word
		# shellcheck disable=SC2059
		[ "$focusbold" = true ] && printf "$term_bold"
		# shellcheck disable=SC2059
		[ -n "$focuscolor" ] && term_color "$focuscolor"
		printf "%s" "$(printf "%s" "$word" | cut -c "$word_focus_pos")"
		# shellcheck disable=SC2059
		{ [ "$focusbold" = true ] || [ -n "$focuscolor" ]; } && printf "$term_reset"

		# Print end of word
		printf "%s" "$(printf "%s" "$word" | cut -c $((word_focus_pos + 1))-)"

	# No focus letter highlighting
	else

		# Set horizontal position of word
		[ $((word_x + word_len)) -le "$term_width" ] && word_x=$((term_x_center - (word_len / 2)))
		term_move "$term_y_center" "$word_x"

		printf "%s" "$word"

	fi

	# Print presentation information
	# shellcheck disable=SC2059
	[ "$proginfo" = true ] && printf "${term_home}${term_clear_line}%s/%s\t%s%%" "$word_num" "$words_count" $(((word_num * 100) / words_count))

	# End word
	term_move "$term_height" 0
	[ $((word_x + word_len)) -gt "$term_width" ] && prev_word_len_exceed=true || prev_word_len_exceed=false

	# Set sleep time
	sleep_time_float=$(calc_float "1000 / (${wpm} / 60)")
	[ "$lengthvary" = true ] && sleep_time_float="$(calc_float "${sleep_time_float} * ($([ "$word_len" -gt "$word_len_average" ] && echo "$word_len" || echo $((word_len_average - 1))) / ${word_len_average})")"
	# Account for word processing time if possible
	[ "$non_posix_date_n" = true ] && sleep_time_float=$(calc_float "${sleep_time_float} + ${word_start_date} - $(get_date)")
	sleep_time_int="${sleep_time_float%.*}"
	{ [ "$sleep_time_int" -lt 0 ] || [ "$sleep_time_int" = "-0" ]; } && {
		sleep_time_float=0
		sleep_time_int=0
	}
	[ "$word_first" = true ] && {
		word_first=false
		[ "$sleep_time_int" -lt 1000 ] && {
			sleep_time_float=1000
			sleep_time_int=1000
		}
	}

	# Sleep
	if [ "$non_posix_sleep" = true ]; then
		sleep "$(calc_float "${sleep_time_float} / 1000")"
	elif [ "$non_posix_usleep" = true ]; then
		usleep $((sleep_time_int * 1000))
	elif [ "$non_posix_date_n" = true ]; then
		sleep_date=$(($(get_date) + sleep_time_int))
		while [ "$(get_date)" -lt "$sleep_date" ]; do
			:
		done
	fi

done

sleep 1 && end_term 0
exit 0
